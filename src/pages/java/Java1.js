import React, { Component } from 'react';

import { Input } from 'antd';
import Markdown  from 'react-markdown';



class Java1 extends Component {
    render() {


        return (
            <div>
                <Markdown source={"### 自旋锁、阻塞锁、可重入锁、悲观锁、乐观锁、读写锁、偏向所、轻量级锁、重量级锁、锁膨胀、对象锁和类锁\n" +
                "\n" +
                "---\n" +
                "\n" +
                "**1、自旋锁**\n" +
                "\n" +
                "自旋锁与互斥锁有点类似，使线程在没有获得锁的时候，就一直循环等待获锁。若在若干个空循环后，线程如果可以获得锁，则继续执行。\n" +
                "\n" +
                "```\n" +
                "线程被挂起:\n" +
                "\t线程的挂起操作实质上就是使线程进入“非可执行”状态下，在这个状态下CPU不会分给线程时间片，进入这个状态可以用来暂停一个线程的运行。在线程挂起后，可以通过重新唤醒线程来使之恢复运行。\n" +
                "\t当一个线程进入“非可执行”状态，必然存在某种原因使其不能继续运行，这些原因可能是如下几种情况：\n" +
                "     A，通过调用sleep()方法使线程进入休眠状态，线程在指定时间内不会运行。\n" +
                "     B，通过调用join()方法使线程挂起，如果某个线程在另一个线程t上调用t.join()，这个线程将被挂起，直到线程t执行完毕为止。\n" +
                "     C，通过调用wait()方法使线程挂起，直到线程得到了notify()和notifyAll()消息，线程才会进入“可执行”状态。\n" +
                "```\n" +
                "\n" +
                "​\t使用自旋锁后，线程被挂起的几率相对减少，线程执行的连贯性相对加强。因此，对于那些锁竞争不是很激烈，锁占用时间很短的并发线程，具有一定的积极意义，**但对于锁竞争激烈，单线程锁占用很长时间的并发程序，自旋锁在自旋等待后，往往毅然无法获得对应的锁，不仅仅白白浪费了CPU时间，最终还是免不了被挂起的操作 ，反而浪费了系统的资源。**\n" +
                "\n" +
                "​\t在JDK1.6中，Java虚拟机提供-XX:+UseSpinning参数来开启自旋锁，使用-XX:PreBlockSpin参数来设置自旋锁等待的次数。\n" +
                "\n" +
                "​\t在JDK1.7开始，自旋锁的参数被取消，虚拟机不再支持由用户配置自旋锁，自旋锁总是会执行，自旋锁次数也由虚拟机自动调整。\n" +
                "\n" +
                "\n" +
                "\n" +
                "**可能引起的问题：**\n" +
                "1.过多占据CPU时间：如果锁的当前持有者长时间不释放该锁，那么等待者将长时间的占据cpu时间片，导致CPU资源的浪费，因此可以设定一个时间，当锁持有者超过这个时间不释放锁时，等待者会放弃CPU时间片阻塞；\n" +
                "\n" +
                "2.死锁问题：试想一下，有一个线程连续两次试图获得自旋锁（比如在递归程序中），第一次这个线程获得了该锁，当第二次试图加锁的时候，检测到锁已被占用（其实是被自己占用），那么这时，线程会一直等待自己释放该锁，而不能继续执行，这样就引起了死锁。因此递归程序使用自旋锁应该遵循以下原则：递归程序决不能在持有自旋锁时调用它自己，也决不能在递归调用时试图获得相同的自旋锁。\n" +
                "\n" +
                "\n" +
                "\n" +
                "---\n" +
                "\n" +
                "**2、阻塞锁**\n" +
                "让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进入运行状态。。\n" +
                "JAVA中，能够进入\\退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字,ReentrantLock，Object.wait()\\notify()\n" +
                "\n" +
                "\n" +
                "\n" +
                "---\n" +
                "\n" +
                "**3、可重入锁**\n" +
                "\n" +
                "可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。\n" +
                "\n" +
                "**在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁**\n" +
                "\n" +
                "可重入锁最大的作用是避免死锁,对于自旋锁来说:\n" +
                "\n" +
                "1、若有同一线程两调用lock() ，会导致第二次调用lock位置进行自旋，产生了死锁,说明这个锁并不是可重入的。\n" +
                "\n" +
                "2、若1问题已经解决，当unlock（）第一次调用时，就已经将锁释放了。实际上不应释放锁。\n" +
                "\n" +
                "\n" +
                "\n" +
                "---\n" +
                "\n" +
                "**4 悲观锁和乐观锁**\n" +
                "\n" +
                "悲观锁(Pessimistic Lock), 顾名思义就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。独占锁是悲观锁的一种实现\n" +
                "\n" +
                "\n" +
                "乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。使用CAS来保证,保证这个操作的原子性\n" +
                "\n" +
                "两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。\n" +
                "\n" +
                "\n" +
                "\n" +
                "----\n" +
                "\n" +
                "5 轮询锁和定时锁**\n" +
                "由tryLock实现，与无条件获取锁模式相比，它们具有更完善的错误恢复机制。可避免死锁的发生：\n" +
                "\n" +
                "boolean tryLock()：仅在调用时锁为空闲状态才获取该锁。如果锁可用，则获取锁，并立即返回值 true。如果锁不可用，则此方法将立即返回值 false。\n" +
                "\n" +
                "```\n" +
                "boolean tryLock(long time, TimeUnit unit) throws InterruptedException：\n" +
                "```\n" +
                "\n" +
                " \n" +
                "\n" +
                "---\n" +
                "\n" +
                "**6 显示锁和内置锁**\n" +
                "显示锁用Lock来定义、内置锁用syschronized。\n" +
                "内置锁：每个java对象都可以用做一个实现同步的锁，这些锁成为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。\n" +
                "\n" +
                "内置锁是互斥锁。\n" +
                "\n" +
                "\n" +
                "\n" +
                "---\n" +
                "\n" +
                "**7 读-写锁**\n" +
                "Lock接口以及对象，使用它，很优雅的控制了竞争资源的安全访问，但是这种锁不区分读写，称这种锁为普通锁。为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。\n" +
                "\n" +
                "Java中读写锁有个接口java.util.concurrent.locks.ReadWriteLock，也有具体的实现ReentrantReadWriteLock，详细的API可以查看JavaAPI文档。\n" +
                "\n" +
                "ReentrantReadWriteLock 和 ReentrantLock 不是继承关系，但都是基于 AbstractQueuedSynchronizer 来实现。\n" +
                "\n" +
                "lock方法 是基于CAS 来实现的\n" +
                "\n" +
                "ReadWriteLock中暴露了两个Lock对象：\n" +
                "\n" +
                "\n" +
                "在读写锁的加锁策略中，允许多个读操作同时进行，但每次只允许一个写操作。读写锁是一种性能优化的策略。\n" +
                "\n" +
                "RentrantReadWriteLock在构造时也可以选择是一个非公平的锁（默认）还是公平的锁。\n" +
                "\n" +
                "\n" +
                "\n" +
                "---\n" +
                "\n" +
                "**8 公平锁&非公平锁**\n" +
                "\n" +
                "公平锁：\n" +
                "\n" +
                "- 公平和非公平锁的队列都基于锁内部维护的一个双向链表，表结点Node的值就是每一个请求当前锁的线程。公平锁则在于每次都是依次从队首取值。\n" +
                "- 锁的实现方式是基于如下几点：\n" +
                "  - 表结点Node和状态state的volatile关键字。\n" +
                "  - `sum.misc.Unsafe.compareAndSet`的原子操作(见附录)。\n" +
                "\n" +
                "非公平锁：\n" +
                "\n" +
                "- 在等待锁的过程中， 如果有任意新的线程妄图获取锁，都是有很大的几率直接获取到锁的。\n" +
                "\n" +
                "> `ReentrantLock`锁都**不会**使得线程中断，除非开发者自己设置了中断位。 \n" +
                "> `ReentrantLock`获取锁里面有*看似*自旋的代码，但是它*不是*自旋锁。 \n" +
                "> `ReentrantLock`公平与非公平锁都是属于排它锁。\n" +
                "\n" +
                "\n" +
                "\n" +
                "---\n" +
                "\n" +
                "**9 对象锁和类锁**\n" +
                "java的对象锁和类锁在锁的概念上基本上和内置锁是一致的，但是，两个锁实际是有很大的区别的，对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。\n" +
                "\n" +
                "类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的.\n" +
                "\n" +
                "synchronized只是一个内置锁的加锁机制，当某个方法加上synchronized关键字后，就表明要获得该内置锁才能执行，并不能阻止其他线程访问不需要获得该内置锁的方法。\n" +
                "\n" +
                "调用对象wait()方法时，会释放持有的对象锁，以便于调用notify方法使用。notify()调用之后，会等到notify所在的线程执行完之后再释放锁\n" +
                "\n" +
                "\n" +
                "\n" +
                "---\n" +
                "\n" +
                "**信号量/栅栏/..**"}/>



            </div>
        );
    }
}

export default Java1;