import React, { Component } from 'react';


class Tree extends Component {
    render() {
        return (
            <div>
                <h2>树</h2>
                <h4>二叉树</h4>
                <p>二叉树是数据结构中一种重要的数据结构，也是树表家族最为基础的结构。</p>
                <p><strong>二叉树的定义：</strong>二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2^(i-1)个结点；深度为k的二叉树至多有2^(k-1)个结点；</p>
                <p>二叉树的示例：</p>
                <p><img src={require('../../img/bc42d6b7087d92bf57edac612206395f.jpg')} /></p>
                <p><strong>满二叉树和完全二叉树：</strong></p>
                <p>满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。</p>
                <p>完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。</p>
                <p><img src={require('../../img/a5952ec741b60202c7b377bfb8e8f368.png')} /></p>
                <h4>二叉查找树</h4>
                <p>二叉查找树定义：又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉排序具有下列性质：</p>
                <p>1) 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p>
                <p>2) 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</p>
                <p>3) 左、右子树也分别为二叉排序树；</p>
                <p>4) 没有键值相等的节点。</p>
                <p>5)<strong>二叉查找树的高度决定了二叉查找树的查找效率。</strong></p>
                <p>6)二叉查找树的插入删除比较复杂，树需要重排序</p>
                <p>&nbsp;</p>
                <h4>平衡二叉树</h4>
                <p>对于一般的二叉搜索树（Binary Search Tree），在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即O(n)。我们可以通过随机化建立二叉搜索树来尽量的避免这种情况，但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。</p>
                <p>平衡二叉树（Balanced Binary Tree）具有以下性质：</p>
                <p>1）它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
                <p>2）其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。</p>
                <h4>平衡查找树(AVL)</h4>
                <p>平衡二叉树同二叉树中没有排序的概念，平衡查找树加入了二叉查找树的排序功能。</p>
                <p>AVL树得名于它的发明者 G.M. Adelson-Velsky 和 E.M. Landis，他们在 1962 年的论文 “An algorithm for the organization of information” 中发表了它。在AVL中任何节点的两个儿子子树的高度最大差别为1，所以它也被称为高度平衡树，n个结点的AVL树最大深度约1.44log2n。查找、插入和删除在平均和最坏情况下都是O(logn)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。</p>
                <p>AVL树最关键的也是最难的一步操作就是<strong>旋转</strong>。旋转主要是为了实现AVL树在实施了插入和删除操作以后，树重新回到平衡的方法。</p>
                <p>只需要经过一次旋转就可以达到目标，我们称之为单旋转，需要进行两次旋转达到目标，我们称之为双旋转。</p>
                <p><strong>单旋转</strong></p>
                <p>单旋转是针对于左左和右右这两种情况的解决方案，这两种情况是对称的，只要解决了左左这种情况，右右就很好办了。图3是左左情况的解决方案，节点k2不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的左子树X子树，所以属于左左情况：</p>
                <p><img src={require('../../img/61ee0c83b3783cb05eac2ed3528eae3b.jpg')} /></p>
                <p><strong>双旋转</strong></p>
                <p>对于左右和右左这两种情况，单旋转不能使它达到一个平衡状态，要经过两次旋转。双旋转是针对于这两种情况的解决方案，同样的，这样两种情况也是对称的，只要解决了左右这种情况，右左就很好办了。图4是左右情况的解决方案，节点k3不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的右子树k2子树，所以属于左右情况。</p>
                <p><img src={require('../../img/2ad609dadbff982036a8e32c792436d7.jpg')} /></p>
                <h4>红黑树</h4>
                <p> 红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。</p>
                <p><strong>红黑树的性质：</strong></p>
                <p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制的一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:</p>
                <p>1）节点是红色或黑色。</p>
                <p>2）根是黑色。</p>
                <p>3） 所有叶子都是黑色（叶子是NIL节点）。</p>
                <p>4） 每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。)</p>
                <p>5） 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</p>
                <p><img src={require('../../img/9fd5e683147961431e0ecfcffbe5805b.png')} /></p>
                <p>这些约束确保了红黑树的关键特性: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。</p>
                <p>要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。</p>
                <p>红黑树的自平衡操作(插入，删除)，比较复杂不做细讲。</p>
            </div>
        );
    }
}

export default Tree;