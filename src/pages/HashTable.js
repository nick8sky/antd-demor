import React, { Component } from 'react';

import { Input } from 'antd';




class HashTable extends Component {
    render() {


        return (
            <div>
                <h2>哈希表</h2>
                <p>	最典型的的例子就是字典，如果我想要获取“安”字详细信息，我们首先去查an的拼音索引在字典的位置，这过程就是键码映射。在公式里面，就是通过key去查找f(key)。其中，按就是关键字（key），f（）就是字典索引，也就是哈希函数，查到的页码4就是哈希值。</p>
                <h4>哈希冲突</h4>
                <p>　　但是问题又来了，我们要查的是“按”，而不是“安，但是他们的拼音都是一样的。也就是通过关键字按和关键字安可以映射到一样的字典页码4的位置，这就是哈希冲突（也叫哈希碰撞），在公式上表达就是key1=key2，但f(key1)=f(key2)。</p>
                <h4>哈希冲突解决办法</h4>
                <p>　　 如果遇到冲突，哈希表一般是怎么解决的呢？具体方法有很多，百度也会有一堆，最常用的就是开发定址法和链地址法。</p>
                <p>　　1.开发定址法(略)</p>
                <p>	遇到冲突的时候查找顺着原来哈希地址查找下一个空闲地址然后插入，但是也有一个问题就是如果空间不足，那他无法处理冲突也无法插入数据，因此需要装填因子(空间/插入数据)&gt;=1。</p>
                <p>　　2.链地址法</p>
                <p>	如果遇到冲突，他就会在原地址新建一个空间，然后以链表结点的形式插入到该空间。业界上用的最多的就是链地址法。可以很清晰明了反应下面的结构。比如说我有一堆数据[1,12,26,337,353...]，而我的哈希算法是H(key)=key mod 16，第一个数据1的哈希值f(1)=1，插入到1结点的后面，第二个数据12的哈希值f(12)=12，插入到12结点，第三个数据26的哈希值f(26)=10，插入到10结点后面，第4个数据337，计算得到哈希值是1，遇到冲突，但是依然只需要找到该1结点的最后链结点插入即可，同理353。</p>
                <p><img src={require('../img/799055-20161226094432226-394173800.png')} /></p>
                <p>	由于哈希表高效的特性，查找或者插入的情况在大多数情况下可以达到O(1)，时间主要花在计算hash上，当然也有最坏的情况就是hash值全都映射到同一个地址上，这样哈希表就会退化成链表，查找的时间复杂度变成O(n)，但是这种情况比较少，只要不要把hash计算的公式外漏出去并且有人故意攻击，一般也不会出现这种情况。</p>
                <h4>拒绝服务攻击</h4>
                <p>哈希表在大部分的Web应用框架上都有应用，我们对Web应用每次发起请求所提交的参数，Controller端都会将其存储在哈希表中供后台代码调用。比如在Asp.NET应用中，我们使用Request.Form[key]和Request.QueryString[key]的方式来获取客户端提交的参数，参数就是被存储在HashTable中的，我们传入参数名称作为Key，通过Hash函数转换成对应的Value的数组下标，然后Value值被返回。</p>
                <p>在正常的应用场景下这没什么问题，现在我们回到上面提到的哈希表退化的问题，如果客户端根据Web应用框架采用的Hash函数来通过某种Hash攻击的方式获得大量的碰撞，那么HashTable就会退化成链表，服务器有可能处理一次请求要花上十几分钟甚至几个小时的时间，一台PC机就可以搞定一台服务器，根本不用分布式攻击。当然攻击能否成功的先决条件是Web应用框架采用的Hash机制存在漏洞。如果存在这样的漏洞，攻击者可以轻而易举的实施拒绝服务攻击。</p>

            </div>
        );
    }
}

export default HashTable;