import React, { Component } from 'react';
import Markdown  from 'react-markdown';



class Mysql8 extends Component {
    render() {


        return (
            <div>
                <Markdown source={"## Mysql分库分表方案(一)\n" +
                "\n" +
                "数据库架构\n" +
                "\n" +
                "1、简单的MySQL主从复制:\n" +
                "\n" +
                "MySQL的主从复制解决了数据库的读写分离，并很好的提升了读的性能，其图如下：\n" +
                "\n" +
                "![Markdown](https://thumbnail0.baidupcs.com/thumbnail/bf11c1c3ced6d017d5d797f5a35b4060?fid=940423185-250528-1058268749389503&time=1520078400&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-oUtDpEoCCSD2x1IUFFj%2F8GoZjTE%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=1434481313978896694&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video)\n" +
                "\n" +
                "其主从复制的过程如下图所示：\n" +
                "\n" +
                "![Markdown](https://thumbnail0.baidupcs.com/thumbnail/ab5d94391761439644da6c4a2b0a83d0?fid=940423185-250528-300728888896907&time=1520078400&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-xELeOilOB5SgGMdWKEiMpKQyb0M%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=1434487021431704846&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video)\n" +
                "\n" +
                "但是，主从复制也带来其他一系列性能瓶颈问题：\n" +
                "\n" +
                "1. 写入无法扩展\n" +
                "\n" +
                "2. 写入无法缓存\n" +
                "\n" +
                "3. 复制延时\n" +
                "\n" +
                "4. 锁表率上升\n" +
                "\n" +
                "5. 表变大，缓存率下降\n" +
                "\n" +
                "那问题产生总得解决的，这就产生下面的优化方案，一起来看看。\n" +
                "\n" +
                "---\n" +
                "\n" +
                "2、MySQL垂直分区\n" +
                "\n" +
                "​\t如果把业务切割得足够独立，那把不同业务的数据放到不同的数据库服务器将是一个不错的方案，而且万一其中一个业务崩溃了也不会影响其他业务的正常进行，并且也起到了负载分流的作用，大大提升了数据库的吞吐能力。经过垂直分区后的数据库架构图如下：\n" +
                "\n" +
                "![Markdown](https://thumbnail0.baidupcs.com/thumbnail/133a0a929b1df5701bec29f174481a50?fid=940423185-250528-492409613055467&time=1520078400&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-w7%2BeBN9HOULsXQNqL2hb4g7gybo%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=1434494074082362383&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video)\n" +
                "\n" +
                "然而，尽管业务之间已经足够独立了，但是有些业务之间或多或少总会有点联系，如用户，基本上都会和每个业务相关联，况且**这种分区方式，也不能解决单张表数据量暴涨的问题**，因此为何不试试水平分割呢？\n" +
                "\n" +
                "---\n" +
                "\n" +
                "3、MySQL水平分片（Sharding）\n" +
                "\n" +
                "这是一个非常好的思路，将用户按一定规则（按id哈希）分组，并把该组用户的数据存储到一个数据库分片中，即一个sharding，原理图如下：\n" +
                "\n" +
                "![Markdown](https://thumbnail0.baidupcs.com/thumbnail/e7c28ef3b3397ebdb4c32ad3759aa86d?fid=940423185-250528-976276264622052&time=1520078400&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-HSc7aphvOb8VNgqX3ntxrl6N4JI%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=1434500586250525136&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video)\n" +
                "\n" +
                "如何来确定某个用户所在的shard呢，可以建一张用户和shard对应的数据表，每次请求先从这张表找用户的shard id，再从对应shard中查询相关数据，如下图所示：\n" +
                "\n" +
                "![Markdown](https://thumbnail0.baidupcs.com/thumbnail/dad3feb8a409e5a7ddd25bad9f2de8a9?fid=940423185-250528-541526602810724&time=1520078400&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-sNTRE1XQUadOOJKDIGlSwkeaN7M%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=1434506147441146966&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video)\n" +
                "\n" +
                "单库单表 \n" +
                "\n" +
                "​\t单库单表是最常见的数据库设计，例如，有一张用户(user)表放在数据库db中，所有的用户都可以在db库中的user表中查到。 \n" +
                "\n" +
                "单库多表 \n" +
                "\n" +
                "​\t随着用户数量的增加，user表的数据量会越来越大，当数据量达到一定程度的时候对user表的查询会渐渐的变慢，从而影响整个DB的性能。如果使用mysql, 还有一个更严重的问题是，**当需要添加一列的时候，mysql会锁表，期间所有的读写操作只能等待。** \n" +
                "\n" +
                "​\t可以通过某种方式将user进行水平的切分，产生两个表结构完全一样的user_0000,user_0001等表，user_0000 + user_0001 + …的数据刚好是一份完整的数据。 \n" +
                "\n" +
                "多库多表 \n" +
                "\n" +
                "​         随着数据量增加也许单台DB的存储空间不够，随着查询量的增加单台数据库服务器已经没办法支撑。这个时候可以再对数据库进行水平区分。 \n" +
                "\n" +
                "---\n" +
                "\n" +
                "分库分表规则 \n" +
                "\n" +
                "​         设计表的时候需要确定此表按照什么样的规则进行分库分表。例如，当有新用户时，程序得确定将此用户信息添加到哪个表中；同理，当登录的时候我们得通过用户的账号找到数据库中对应的记录，所有的这些都需要按照某一规则进行。\n" +
                "\n" +
                " \n" +
                "路由 \n" +
                "\n" +
                "​         通过分库分表规则查找到对应的表和库的过程。如分库分表的规则是user_id mod 4的方式，当用户新注册了一个账号，账号id的123,我们可以通过id mod 4的方式确定此账号应该保存到User_0003表中。当用户123登录的时候，我们通过123 mod 4后确定记录在User_0003中。 \n" +
                "\n" +
                "\n" +
                "\n" +
                "分库分表产生的问题，及注意事项：\n" +
                "\n" +
                "1、分库分表维度的问题\n" +
                "\n" +
                "​\t假如用户购买了商品,需要将交易记录保存取来，如果按照用户的纬度分表，则每个用户的交易记录都保存在同一表中，所以很快很方便的查找到某用户的购买情况，但是某商品被购买的情况则很有可能分布在多张表中，查找起来比较麻烦。反之，按照商品维度分表，可以很方便的查找到此商品的购买情况，但要查找到买人的交易记录比较麻烦。 \n" +
                "\n" +
                "\n" +
                "\n" +
                "所以常见的解决方式有： \n" +
                "\n" +
                "​     a.记录两份数据，一份按照用户纬度分表，一份按照商品维度分表。 \n" +
                "\n" +
                "​     b.通过搜索引擎解决，但如果实时性要求很高，又得关系到实时搜索。 \n" +
                "\n" +
                "2、联合查询的问题 \n" +
                "\n" +
                "​\t联合查询基本不可能，因为关联的表有可能不在同一数据库中。 \n" +
                "\n" +
                "\n" +
                "\n" +
                "3、避免跨库事务 \n" +
                "\n" +
                "​\t避免在一个事务中修改db0中的表的时候同时修改db1中的表，一个是操作起来更复杂，效率也会有一定影响。 \n" +
                "\n" +
                "\n" +
                "\n" +
                "4、尽量把同一组数据放到同一DB服务器上 \n" +
                "\n" +
                "​\t例如将卖家a的商品和交易信息都放到db0中，当db1挂了的时候，卖家a相关的东西可以正常使用。也就是说避免数据库中的数据依赖另一数据库中的数据。 \n" +
                "\n" +
                "\n" +
                "\n" +
                "---\n" +
                "\n" +
                "一主多备 \n" +
                "\n" +
                "在实际的应用中，绝大部分情况都是读远大于写。Mysql提供了读写分离的机制，所有的写操作都必须对应到Master，读操作可以在 Master和Slave机器上进行，Slave与Master的结构完全一样，一个Master可以有多个Slave,甚至Slave下还可以挂 Slave,通过此方式可以有效的提高DB集群的 QPS.                                                       \n" +
                "\n" +
                "所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。 \n" +
                "\n" +
                "此外，可以看出Master是集群的瓶颈，当写操作过多，会严重影响到Master的稳定性，如果Master挂掉，整个集群都将不能正常工作。 \n" +
                "\n" +
                "所以：\n" +
                "\n" +
                "1. 当读压力很大的时候，可以考虑添加Slave机器的分式解决，但是当Slave机器达到一定的数量就得考虑分库了。\n" +
                "2. 当写压力很大的时候，就必须得进行分库操作。 \n" +
                "\n" +
                "---\n" +
                "\n" +
                "MySQL使用为什么要分库分表 \n" +
                "可以用说用到MySQL的地方,只要数据量一大, 马上就会遇到一个问题,要分库分表. \n" +
                "这里引用一个问题为什么要分库分表呢?MySQL处理不了大的表吗? \n" +
                "其实是可以处理的大表的.我所经历的项目中单表物理上文件大小在80G多,单表记录数在5亿以上,而且这个表 \n" +
                "属于一个非常核用的表:朋友关系表. \n" +
                "\n" +
                "但这种方式可以说不是一个最佳方式. 因为面临文件系统如Ext3文件系统对大于大文件处理上也有许多问题. \n" +
                "这个层面可以用xfs文件系统进行替换.但MySQL单表太大后有一个问题是不好解决: 表结构调整相关的操作基 \n" +
                "本不在可能.所以大项在使用中都会面监着分库分表的应用. \n" +
                "\n" +
                "从Innodb本身来讲数据文件的Btree上只有两个锁, 叶子节点锁和子节点锁,可以想而知道,当发生页拆分或是添加 \n" +
                "新叶时都会造成表里不能写入数据. \n" +
                "所以分库分表还就是一个比较好的选择了. \n" +
                "\n" +
                "那么分库分表多少合适呢? \n" +
                "经测试在单表1000万条记录一下,写入读取性能是比较好的. 这样在留点buffer,那么单表全是数据字型的保持在 \n" +
                "800万条记录以下, 有字符型的单表保持在500万以下. \n" +
                "\n" +
                "如果按 100库100表来规划,如用户业务: \n" +
                "500万 X 100  X 100 = 50000000万 = 5000亿记录. \n" +
                "\n" +
                "心里有一个数了,按业务做规划还是比较容易的."}/>




            </div>
        );
    }
}

export default Mysql8;