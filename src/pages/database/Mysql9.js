import React, { Component } from 'react';
import Markdown  from 'react-markdown';



class Mysql9 extends Component {
    render() {


        return (
            <div>
                <Markdown source={"## Mysql分表和分区的区别、分库分表介绍与区别\n" +
                "\n" +
                "分表和分区的区别：\n" +
                "\n" +
                "一，什么是mysql分表，分区 \n" +
                "​\t什么是分表，从表面意思上看呢，就是把一张表分成N多个小表，具体请看:mysql分表的3种方法\n" +
                "​\t什么是分区，分区呢就是把一张表的数据分成N多个区块，这些区块可以在同一个磁盘上，也可以在不同的磁盘上，具体请参考mysql分区功能详细介绍，以及实例 \n" +
                "二，mysql分表和分区有什么区别呢 \n" +
                "1，实现方式上 \n" +
                "​\ta）mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完正的一张表，都对应三个文件，一个**.MYD数据文件，.MYI索引文件，.frm表结构文件。** \n" +
                "\n" +
                "```\n" +
                "[root@BlackGhost test]# ls |grep user\n" +
                "alluser.MRG\n" +
                "alluser.frm\n" +
                "user1.MYD\n" +
                "user1.MYI\n" +
                "user1.frm\n" +
                "user2.MYD\n" +
                "user2.MYI\n" +
                "user2.frm \n" +
                "```\n" +
                "\n" +
                "​\t简单说明一下，上面的分表呢是利用了merge存储引擎（分表的一种），alluser是总表，下面有二个分表，user1，user2。他们二个都是独立的表，取数据的时候，我们可以通过总表来取。这里总表是没有.MYD,.MYI这二个文件的，也就是说，总表他不是一张表，没有数据，数据都放在分表里面。我们来看看.MRG到底是什么东西 \n" +
                "\n" +
                "```\n" +
                "[root@BlackGhost test]# cat alluser.MRG |more\n" +
                "user1\n" +
                "user2\n" +
                "#INSERT_METHOD=LAST \n" +
                "```\n" +
                "\n" +
                "​\t从上面我们可以看出，alluser.MRG里面就存了一些分表的关系，以及插入数据的方式。可以把总表理解成一个外壳，或者是联接池。 \n" +
                "\n" +
                "​\tb）分区不一样，一张大表进行分区后，他还是一张表，不会变成二张表，但是他存放数据的区块变多了。 \n" +
                "\n" +
                "```\n" +
                "[root@BlackGhost test]# ls |grep aa\n" +
                "aa#P#p1.MYD\n" +
                "aa#P#p1.MYI\n" +
                "aa#P#p3.MYD\n" +
                "aa#P#p3.MYI\n" +
                "aa.frm\n" +
                "aa.par\n" +
                "```\n" +
                "\n" +
                "​\t从上面我们可以看出，aa这张表，分为二个区，p1和p3，本来是三个区，被我删了一个区。我们都知道一张表对应三个文件.MYD,.MYI,.frm。分区呢根据一定的规则把数据文件和索引文件进行了分割，还多出了一个.par文件，打开.par文件后你可以看出他记录了，这张表的分区信息，根分表中 的.MRG有点像。分区后，还是一张，而不是多张表。 \n" +
                "如查询语句: orderid,userid,ordertime,.....\n" +
                "ordertime<2015-01-01 #p0\n" +
                "ordertime<2015-04-01 #p1\n" +
                "ordertime<2015-07-01 #p2\n" +
                "ordertime<2015-10-01 #p3\n" +
                "ordertime<2016-01-01 #p4\n" +
                "​\t如果是按照时间分区。大部分只查询最近的订单数据，那么大部分只访问一个分区，比整个表小多了，数据库可以更加好的缓存，性能也提高了。这个是数据库分的，应用程序透明，无需修改。\n" +
                "\n" +
                "\n" +
                "\n" +
                "2，数据处理上 \n" +
                "\n" +
                "a）分表后，数据都是存放在分表里，总表只是一个外壳，存取数据发生在一个一个的分表里面。看下面的例子： \n" +
                "\n" +
                "select * from alluser where id='12'表面上看，是对表alluser进行操作的，其实不是的。是对alluser里面的分表进行了操作。 \n" +
                "\n" +
                "b）分区呢，不存在分表的概念，分区只不过把存放数据的文件分成了许多小块，分区后的表呢，还是一张表。但要加上分区条件，不然会全表扫描。\n" +
                "\n" +
                "\n" +
                "\n" +
                "三，mysql分表和分区有什么联系呢 \n" +
                "\n" +
                "**1，都能提高mysql的性高，在高并发状态下都有一个良好的表面。** \n" +
                "\n" +
                "2，**分表和分区不矛盾**，可以相互配合的，对于那些大访问量，并且表数据比较多的表，我们可以采取分表和分区结合的方式（如果merge这种分表方式，不能和分区配合的话，可以用其他的分表试），访问量不大，但是表数据很多的表，我们可以采取分区的方式等。\n" +
                "\n" +
                " \n" +
                "\n" +
                "**分库分表区别：**\n" +
                "\n" +
                "1 基本思想之什么是分库分表？\n" +
                "从字面上简单理解，就是把原本存储于一个库的数据分块存储到多个库上，把原本存储于一个表的数据分块存储到多个表上。\n" +
                "\n" +
                "2 基本思想之为什么要分库分表？\n" +
                "​\t数据库中的数据量不一定是可控的，在未进行分库分表的情况下，随着时间和业务的发展，库中的表会越来越多，表中的数据量也会越来越大，相应地，数据操作，增删改查的开销也会越来越大；另外，一台服务器的资源（CPU、磁盘、内存、IO等）是有限的，最终数据库所能承载的数据量、数据处理能力都将遭遇瓶颈,。\n" +
                "\n" +
                "3 分库分表的实施策略。\n" +
                "​\t如果你的单机性能很低了，那可以尝试分库。分库，业务透明，在物理实现上分成多个服务器，不同的分库在不同服务器上。分区可以把表分到不同的硬盘上，但不能分配到不同服务器上。一台机器的性能是有限制的，用分库可以解决单台服务器性能不够。\n" +
                "\n" +
                "---\n" +
                "\n" +
                "分库分表有垂直切分和水平切分两种。\n" +
                "​\t3.1 何谓垂直切分，即将表**按照功能模块**、关系密切程度划分出来，部署到不同的库上。例如，我们会建立定义数据库workDB、商品数据库payDB、用户数据库userDB、日志数据库logDB等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。\n" +
                "\n" +
                "```\n" +
                "如userid,name,addr一个表，为了防止表过大，分成2个表。\n" +
                "userid,name\n" +
                "userid,addr\n" +
                "```\n" +
                "\n" +
                "​\t 3.2 何谓水平切分，**将一张表按照某种规则存储到多个结构相同的表，和不同的库上**； 例如userID散列、按性别、按省，进行划分；例如，我们的userDB中的用户数据表中，每一个表的数据量都很大，就可以把userDB切分为结构相同的多个userDB：part0DB、part1DB等，再将userDB上的用户数据表userTable，切分为很多userTable：userTable0、userTable1等，然后将这些表按照一定的规则存储到多个userDB上。\n" +
                "\n" +
                "​\t3.3 应该使用哪一种方式来实施数据库分库分表，这要看数据库中数据量的瓶颈所在，并综合项目的业务类型进行考虑。\n" +
                "​\t如果数据库是因为表太多而造成海量数据，并且项目的各项业务逻辑划分清晰、低耦合，那么规则简单明了、容易实施的垂直切分必是首选。\n" +
                "\n" +
                "​\t而如果数据库中的表并不多，但单表的数据量很大、或数据热度很高，这种情况之下就应该选择水平切分，水平切分比垂直切分要复杂一些，它将原本逻辑上属于一体的数据进行了物理分割，除了在分割时要对分割的粒度做好评估，考虑数据平均和负载平均，后期也将对项目人员及应用程序产生额外的数据管理负担。\n" +
                "\n" +
                "​\t在现实项目中，往往是这两种情况兼而有之，这就需要做出权衡，甚至既需要垂直切分，又需要水平切分。我们的游戏项目便综合使用了垂直与水平切分，我们首先对数据库进行垂直切分，然后，再针对一部分表，通常是用户数据表，进行水平切分。\n" +
                "\n" +
                "---\n" +
                "\n" +
                "分库分表存在的问题。\n" +
                "4.1 事务问题。\n" +
                "​\t在执行分库分表之后，由于数据存储到了不同的库上，数据库事务管理出现了困难。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。\n" +
                "\n" +
                "4.2 跨库跨表的join问题。\n" +
                "​\t在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上，这时，表的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表，结果原本一次查询能够完成的业务，可能需要多次查询才能完成。\n" +
                "\n" +
                "4.3 额外的数据管理负担和数据运算压力\n" +
                "​\t额外的数据管理负担，最显而易见的就是数据的定位问题和数据的增删改查的重复执行问题，这些都可以通过应用程序解决，但必然引起额外的逻辑运算，例如，对于一个记录用户成绩的用户数据表userTable，业务要求查出成绩最好的100位，在进行分表之前，只需一个order by语句就可以搞定，但是在进行分表之后，将需要n个order by语句，分别查出每一个分表的前100名用户数据，然后再对这些数据进行合并计算，才能得出结果。"}/>




            </div>
        );
    }
}

export default Mysql9;