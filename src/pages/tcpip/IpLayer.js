import React, { Component } from 'react';

class ARP extends Component {
    render() {
        return (
            <div>
                <h2>网际协议IP</h2>
                <p>以太网帧首部</p>
                {/*<p><img src={require('../../img/20161013182456810.png')} style={{height:"60%",width:"60%"}}/></p>*/}

                <p><img src="http://i4.bvimg.com/633340/71e2f36d264f71e8.png" style={{height:"60%",width:"60%"}}/></p>
                <p>=目的地址+源地址+子模块类型+子模块数据</p>
                <p>IP报头首部</p>
                {/*<p><img src={require('../../img/20161013182606405.png')} style={{height:"60%",width:"60%"}}/></p>*/}

                <p><img src="http://i4.bvimg.com/633340/c67265d4fe245518.png" style={{height:"60%",width:"60%"}}/></p>
                <p>=TTL + 源ip地址 + 目的ip地址 + 协议 + 数据；</p>
                <p>普通的IP首部长为20个字节，除非含有选项字段。</p>
                <p>4位版本：目前协议版本号是4，因此IP有时也称作IPV4.</p>
                <p>4位首部长度：首部长度指的是首部占32bit字的数目，包括任何选项。由于它是一个4比特字段，因此首部长度最长为60个字节。</p>
                <p>服务类型（TOS）：服务类型字段包括一个3bit的优先权字段（现在已经被忽略），4bit的TOS子字段和1bit未用位必须置0。4bit的TOS分别代表：最小时延，最大吞吐量，最高可靠性和最小费用。4bit中只能置其中1比特。如果所有4bit均为0，那么就意味着是一般服务。</p>
                <p>总长度：总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长16bit，所以IP数据报最长可达65535字节。当数据报被分片时，该字段的值也随着变化。</p>
                <p>标识字段：标识字段唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。</p>
                <p>生存时间：TTL（time-to-live）生存时间字段设置了<strong>数据报可以经过的最多路由器数</strong>。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为 32,45,64,255），一旦经过一个处理它的路由器，它的值就减去 1。当该字段的值为 0时，数据报就被丢弃，并发送 ICMP报文通知源主机。</p>
                <p>首部检验和：首部检验和字段是根据 IP首部计算的检验和码。它不对首部后面的数据进行计算?</p>
                <p>&nbsp;</p>
                <h3>IP路由选择</h3>
                <p>	从概念上说，IP路由选择是简单的，特别对于主机来说。如果目的主机与源主机直接相连(如点对点链路)或都在一个共享网络上(以太网或令牌环网)，那么IP数据报就直接送到目的主机上。否则，主机把数据报发往一默认的路由器上，由路由器来转发该数据报。大多数的主机都是采用这种简单机制。
                </p>
                <h3>子网寻址</h3>
                <p>p问题引入</p>p>

                <p>     1.IP地址利用率有时很低。</p>
                <p>     2.给每一个物理网络分配一个网络号会使路由表变得太大而使网络性能变坏。</p>
                <p>为了解决上述问题，1985年起在IP地址中增加了一个“子网号字段”，使IP地址变为多级IP地址。这种方法叫做划分子网( subnetting ), 或子网寻址或子网路由选择。</p>
                <p>划分子网的基本思路如下：</p>p>
                <p>    1. 一个拥有许多主机的单位，可将主机划分为若干个子网( subnet )。划分子网纯属一个单位内部的事情。本单位以外的网络看不见这个网络是由多少个子网组成，因为这个单位对外仍然表现为一个网络。</p>
                <p>    2. 划分子网的方法是从网络的主机号借用若干位作为子网号 subnet-id，当然主机号也就相应减少了同样的位数。于是两级IP地址在本单位内部就变成三级IP地址：网络号、子网号和主机号。也可以用以下记法来表示：</p>
                <p>IP地址 ::= [ &lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;]</p>
                <p>有点类似三级交换机。</p>
                <p>    3. 凡是从其他网络发送给本单位某个主机的IP数据报，仍然是根据IP数据报的目的网络号找到连接在本单位网络上的路由器。但此路由器在收到IP数据报后，再按目的网络号和子网号找到目的子网，把IP数据报交付给目的主机。</p>
                <h3>子网掩码</h3>
                <p>从IP数据报的首部并不知道源主机或目的主机所连接的网络是否进行了子网划分。这是因为32位的IP地址本身以及数据报的首部都没有包含任何有关子网划分的信息。因此必须想办法，使IP数据报到达时路由器知道如何把它转发至某个子网。这就是<strong>子网掩码</strong>(** subnet mask **)。</p>
                <p>子网掩码：也是32位，由一串1和跟随的一串0组成。子网掩码中的1对应于IP地址中原来的 net-id 加上 subnet-id，而子网掩码中的0对应于现在的 host-id 。</p>
                <p>使用子网掩码的好处是：不管网络有没有划分子网，只要把子网掩码和IP地址进行逐位的“与”运算（ AND ），就立即得出网络地址来。</p>
                {/*<p><img src={require('../../img/2010100518305958.jpg')} style={{height:"45%",width:"45%"}}/></p>*/}

                <p><img src="http://i4.bvimg.com/633340/5a8d2f820de2f5e6.jpg" style={{height:"45%",width:"45%"}}/></p>
                {/*<p><img src={require('../../img/WX20180220-135806@2x.png')} style={{height:"60%",width:"60%"}}/></p>*/}

                <p><img src="http://i4.bvimg.com/633340/043ae129902cf221.png" style={{height:"60%",width:"60%"}}/></p>
                {/*<p><img src={require('../../img/WX20180220-135849@2x.png')} style={{height:"60%",width:"60%"}}/></p>*/}

                <p><img src="http://i4.bvimg.com/633340/84cf2bfbbd71f368.png" style={{height:"60%",width:"60%"}}/></p>
                <p>140.252.13子网中的所有接口的子网掩码是255.255.255.224，或0xffffffe0。这表明最右边的5bit留给主机号，左边的27bit留给网络号和子网号。
                    所有接口的IP地址和子网掩码的分配情况如图</p>
                {/*<p><img src={require('../../img/WX20180220-135943@2x.png')} style={{height:"60%",width:"60%"}}/></p>*/}

                <p><img src="http://i4.bvimg.com/633340/973c9970398808b6.png" style={{height:"60%",width:"60%"}}/></p>
                <p>VLSM(Variable Length Subnet masks)
                    <strong>变长子网掩码</strong></p>
                <p>我们可能会被它的字面意思给弄糊涂了，什么变长子网掩码，实际上子网掩码的大小不会自己改变的，VLSM的意思是不同子网的子网掩码可能有不同的长度，但一旦子网掩码的长度确定了，它们就不变了。这个技术对于高效分配IP地址，减少路由表的大小非常有用，但是如果使用不当可能会造成意想不到的错误。</p>
                <p>&nbsp;</p>
                <p>　我们知道IP地址是一个4字节（共32bit）的数字，被分为4段，每段8位，段与段之间用句点分隔。为了便于表达和识别，IP地址是以十进制形式表示的如210.52.207.2，每段所能表示的十进制数最大不超过255。IP地址由两部分组成，<strong>即网络号（Netgwork ID）和主机号（Host ID）</strong>。网络号标识的是Internet上的一个子网，而主机号标识的是子网中的某台主机。网际地址分解成两个域后，带来了一个重要的优点：IP数据包从网际上的一个网络到达另一个网络时，选择路径可以基于网络而不是主机。在大型的网际中，这一点优势特别明显，因为路由表中只存储网络信息而不是主机信息，这样可以大大简化路由表。IP地址根据网络号和主机号的数量而分为A、B、C三类：</p>
                <p>　A类IP地址：用7位（bit）来标识网络号，24位标识主机号，最前面一位为&quot;0&quot;，即A类地址的第一段取值介于1～126之间。A类地址通常为大型网络而提供，全世界总共只有126个只可能的A类网络，每个A类网络最多可以连接16777214台主机。 0+7[a]+24[b]</p>
                <p>　B类IP地址：用14位来标识网络号，16位标识主机号，前面两位是&quot;10&quot;。B类地址的第一段取值介于128～191之间，第一段和第二段合在一起表示网络号。B类地址适用于中等规模的网络，全世界大约有16000个B类网络，每个B类网络最多可以连接65534台主机。 10+14[a]+16[b]</p>
                <p>　C类IP地址：用21位来标识网络号，8位标识主机号，前面三位是&quot;110&quot;。C类地址的第一段取值介于192～223之间，第一段、第二段、第三段合在一起表示网络号。最后一段标识网络上的主机号。C类地址适用于校园网等小型网络，每个C类网络最多可以有254台主机。110+21[a]+8[b]</p>
                <p>　从上面的介绍我们知道，IP地址是以网络号和主机号来标示网络上的主机的，只有在一个网络号下的计算机之间才能&quot;直接&quot;互通，不同网络号的计算机要通过网关（Gateway）才能互通。但这样的划分在某些情况下显得并十分不灵活。为此IP网络还允许划分成更小的网络，称为子网（Subnet），这样就产生了子网掩码。子网掩码的作用就是用来判断任意两个IP地址<strong>是否属于同一子网络</strong>，这时只有在同一子网的计算机才能&quot;直接&quot;互通。那么怎样确定子网掩码呢？</p>
                <p>　前面讲到IP地址分网络号和主机号，要将一个网络划分为多个子网，因此子网络号将要占用原来的主机位，如对于一个C类地址，它用21位来标识网络号，要将其划分为2个子网则需要占用1位原来的主机标识位。此时网络号位变为22位为主机标示变为7位。同理借用2个主机位则可以将一个C类网络划分为4个子网……那计算机是怎样才知道这一网络是否划分了子网呢？这就可以从子网掩码中看出。子网掩码和IP地址一样有32bit，确定子网掩码的方法是其与IP地址中标识网络号的所有对应位都用&quot;1&quot;，而与主机号对应的位都是&quot;0&quot;。如分为2个子网的C类IP地址用22位来标识网络号，则其子网掩码为：11111111 11111111 11111111 10000000即255.255.255.128。于是我们可以知道，A类地址的缺省子网掩码为255.0.0.0,B类为255.255.0.0,C类为255.255.255.0。下表是C类地址子网划分及相关子网掩码：</p>
                <p>110+22[a]+7[b] ==11111111 11111111 11111111 10000000</p>
                <p>110+21[a]+8[b] ==11111111 11111111 11111111 00000000</p>
                <p>=&gt;</p>
                <figure><table>
                    <thead>
                    <tr><th>子网位数</th><th>子网掩码</th><th>主机数</th><th>可用主机数</th></tr></thead>
                    <tbody><tr><td>1</td><td>255.255.255.128</td><td>128</td><td>126</td></tr><tr><td>2</td><td>255.255.255.192</td><td>64</td><td>62</td></tr><tr><td>3</td><td>255.255.255.224</td><td>32</td><td>30</td></tr><tr><td>4</td><td>255.255.255.230</td><td>16</td><td>14</td></tr><tr><td>5</td><td>255.255.255.248</td><td>8</td><td>6</td></tr><tr><td>6</td><td>255.255.255.252</td><td>4</td><td>2</td></tr></tbody>
                </table></figure>
                <p>&nbsp;</p>

            </div>
        );
    }
}

export default ARP;