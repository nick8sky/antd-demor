import React, { Component } from 'react';

class CTO3 extends Component {
    render() {
        return (
            <div>
                <h2>[转]架构师之路：一个架构师需要掌握的知识技能</h2>
                <p>没有设计的思想，你就不能成为一名架构师。架构师是一个能撸的了一手好代码，画的了一个漂亮的UML/原型，写的了一篇技术文档，更加能解决好项目关键技术的综合人才。架构师=前端工程师+后端程序员+系统分析师+关键技术解决+各种技术搭配+设计模式+部署调优+数据库+其他，可见架构师是多面手，在项目当中起到连接管理与项目成员的重要角色。因此，在通往大神级的架构师的道路上，你需要懂需求、设计、代码、部署、架构、服务器、运维、调优等等。</p>
                <p>&nbsp;</p>
                <p>大部分烂代码并不是架构师的设计问题，如果程序员没能很好的理解设计或者是经验不足，往往会做出一些非常匪夷所思的东西。比如我见过刚毕业的程序员为了防止模块耦合而将耦合的代码又拷贝了一份，或者为了“优化性能”而尽量把所有逻辑写在一个函数里。</p>
                <p>如果不能及时发现并改正这些问题，那么这些地方就会变成“正确的错误代码”，或者”不是我写的“代码，或者”我也看过那段代码“之类足以被挂上耻辱柱的玩意。这种问题算是架构师的责任吗？作为一个视名声如命的架构师，我认为是的。</p>
                <p>在我看来，写代码的架构师更像是在做后勤保障的工作：在代码中第一时间发现可能存在的问题，向其他人提出警告，或是给予其他人改进的意见，必要的时候或是给其他人演示一下正确的姿势。</p>
                <p>&nbsp;</p>
                <p>大部分情况下我作为架构师并不需要揽下“核心模块”开发这种工作，毕竟我能调配的时间太零散了，效率难以保证，很多人在专注的情况下比我做的好很多，我只需要保持大局观需要适度参与就可以了。</p>
                <p>总的来说，架构师和程序员在某些方面上有点像产品经理和用户的关系，大部分程序员并不会主动告诉你他们想要什么、哪里需要优化，甚至自己也不知道这些。想要做出好的产品，捷径之一就是跟用户做同样的事情。</p>
                <p>&nbsp;</p>
                <blockquote><p>实践：开会是个技术活吗？</p>
                </blockquote>
                <p>我觉得应该没有人喜欢开会，身为一个程序员，没有几个人的志向是当什么职场交际花。</p>
                <p>但是会议邀请就这么一个个的跳了出来：开发需求要跟产品开会、项目方案要跟技术开会、新人转正要去开评审会、别的公司来了几个大牛正在开分享会、出了故障要开总结会、小组有周会、部门有周会，大项目每周开两次碰头会不过分吧？小项目启动的时候开个会不过分吧？调试的时候发现有个坑大家赶紧讨论讨论吧？</p>
                <p>有时候参加的会议整场下来跟我毛关系都没有，全程神游俩钟头，最后突然有人一拍桌子：”还有问题没？好，散了！“</p>
                <p>也有可能有个什么会没叫你，过了俩礼拜突然收到封邮件催开发进度，”当时那个会你没参加，大家都说应该是你们做……你没看会议纪要吗？“</p>
                <p>吐槽了这么多，但我还是认为开会是个技术活，对于架构师来说尤其如此。</p>
                <p>大多数技术人员开会并不是那种新闻里的工作汇报或者长者们的会议，他们真的需要通过开会讨论一个具体方案，或者解决什么具体问题。可惜的是我参加过很多会议，大多数的会议都是在毫无意义的交流中浪费时间：几方人坐在一个屋里互相说一些对方理解不了的话，最后得出一个”我们会后再捋一捋“之类的结论。</p>
                <p>这并不是会议才有的问题，在程序员日常的沟通中，也有很多人并不懂得如何交流，比如偶尔会收到一些写的非常认真的邮件，打开之后是密密麻麻的一屏幕文字，但是从第一句开始就不知道他在说什么，后面的东西连看的动力都没有了。</p>
                <p>大多数时候，沟通的核心不是你说了什么，而是你想要让对方了解什么、让他做什么。良好的沟通能在工作中显著提升效率，但很多人忽略了这个事情。</p>
                <p>想要恰到好处的进行沟通是一件不那么轻松的事情，但是简单来说有几条原则：</p>
                <ol>
                    <li><strong>确保各方对背景的理解一致</strong>，比如开会之前先简单通过邮件交流一下，对新加入会议的人花个30秒钟做个前情提要，或者在讨论过程中让对方说一下他的理解。</li>
                    <li><strong>去掉对方不能/不需要理解的内容</strong>，比如跟产品说“这个队列在高并发下因为锁的实现有问题导致CPU性能瓶颈”不如改成“我们发现了性能问题，持续10分钟了，10万用户收不到运营发的无节操广告，大概5分钟后扩容解决”。</li>
                    <li><strong>确保在对方失去注意力前尽快说出重点</strong>，比如排查问题的总结邮件，如果第一段是这样：“某某框架内部使用的是xxx技术，这个技术的架构是这样：blabla”，那么对方可能完全不知道你在讲什么。可以换成这样：“我发现了某某框架的bug，需要尽快升级，否则在xxx情况下有可能会出现yyy问题，具体排查过程如下：blabla”。</li>
                    <li><strong>不要说没有意义的内容浪费其他人的时间</strong>，比如”这需求做不了“或者”这里不可能出bug“，没有人想听到这些废话。</li>

                </ol>
                <p>&nbsp;</p>
                <blockquote><p>为什么别人的系统总是那么烂？</p>
                </blockquote>
                <p>很多程序员解决问题的能力很强，说要解决一个什么问题，下午就能写出几百行代码把功能实现了。但是做出来的东西有种少考虑了什么东西的感觉，我花了挺久去想一个词去形容“这个东西”，最后想出了个勉强可以表达的词：程序的生命力。</p>
                <p>大部分程序都能实现功能，但是如果把“时间”这个也作为一个考虑的维度的话，就会意识到一个合格的项目需要考虑更多的东西：更通用的使用方式、易于理解的文档、简单而易于扩展的设计，等等。而想要毁掉程序的生命力也很简单：做的更复杂，更定制化，让更少的人参与。</p>
                <p>我跟很多程序员提过程序的生命力，比如说要让自己写的工具的操作方式跟其它Linux命令类似，或者要用一些更容易理解但不是性能最优的设计方式，又或者要他去参考现在业界主流的做法，很多人认为提这种需求的意义不大，我觉得这里还是举个例子吧。</p>
                <p>很多公司应该都会有一些遗留系统，它们庞大、笨重、难用、几乎无法维护，所有人都在抱怨这些系统，并且每天都在想方设法换掉那些遗留系统。但是一段时间过去之后，又会发现身边的新人又开始吐槽当时替代遗留系统的那个系统了。</p>
                <p>“大多数系统当初都很好使，功能当时够用，扩展性看起来也可以，但是这些系统都是开发的人离职之后变坏的。”</p>
                <p>&nbsp;</p>
                <blockquote><p>还有更好的办法吗？</p>
                </blockquote>
                <p>成为技术专家之后的工作可以说是痛并快乐着，会有很多人找你咨询问题，另一方面，会有太多人找你咨询问题。</p>
                <p>甚至有一段时间我每天的工作就是解答问题，小到工具使用中到疑难bug，大到架构设计，从早上到晚上基本都是在给各种各样的小伙伴提供咨询服务。</p>
                <p>我很快发现有些地方不对头：有些问题实在是太简单了，以至于我甚至都不用思考就可以给出答案，为什么会有这种问题？</p>
                <p>后来我在每次回答之前先问一句：</p>
                <p>“你还有更好的办法吗？”</p>
                <p>一小部分人立刻能给出优化后的版本，甚至我连续问几次之后，他能给出好几个优化后的版本；另小一部分人会斩钉截铁的说优化不了了，就这样了。但是大部分人会犹犹豫豫的说出一些完全不着调的回答。</p>
                <p>后来我改成在每次回答之前先问两句：</p>
                <p>“你要解决什么问题?”</p>
                <p>“还有更好的办法吗？”</p>
                <p>效果好了很多，很多小伙伴发现要解决的问题并不复杂，只是做法跑偏了。</p>
                <p>再后来我改成了在每次回答之前先问三句：</p>
                <p>“他们要你解决什么问题？”</p>
                <p>“你解决的是什么问题？“</p>
                <p>”还有更好的办法吗？“</p>
                <p>现在第三句已经很少问到了。</p>
                <p>&nbsp;</p>
                <blockquote><p>成为架构师最困难的门槛是什么？</p>
                </blockquote>
                <p>跟一些程序员交流的过程中，有不少人问我要怎么成为一名牛逼的架构师。</p>
                <p>我最近几年面试的人挺多，发现一个有意思的现象：很多人自称架构师的人跟你讲一个架构时简直滔滔不绝，各种技术名词像是说相声一样从他嘴里说出来，三句话不离高并发大数据，但是稍微追问一下，就会发现很多基本概念的缺失，例如自称精通高并发的人说不清楚他所谓的高并发系统的瓶颈在哪里，自称精通架构设计的人说不明白他的系统怎么保证高可用，自称超大数据量的系统实际上只有不到100万条数据，等等。</p>
                <p>架构师虽然听起来很高大上，但本质上仍然是工程师，不是科学家，也不是忽悠人的江湖骗子。学习再多，也需要实践落地。设计架构方案更多的是在做一些抽象和权衡：把复杂的需求抽象成简单的模型，从功能、性能、可用性、研发成本等等方面规划如何构建一个系统，这些内容需要更多的实践练习。</p>
                <p>很多人没有工作在类似微博平台这种天天需要接触架构设计的地方，而很多公司没有架构方面的工作可供他们练级，于是就想办法从理论上下功夫，这类人的特征非常明显：在信息不足，甚至不了解实际场景的情况下就开始做架构设计，这种所谓的架构往往理解比较肤浅，经不住推敲。</p>
                <p>每年招人之后我们都会做一些针对新人的架构方面的培训，课程材料基本上包括了高可用架构相关的主要方面，但是学完这些材料之后就能成为独当一面的架构师了吗？并没有。相反，这仅仅是开始，新人真正做了几个并发量上万的系统之后才算是正式入门：面对压力时才会懂得权衡，走过弯路之后才会寻找捷径。</p>
                <p>所以我认为在架构师（和其它很多）的工作中最重要的部分是实践，夸夸其谈很容易，与其拽一些技术名词，不如把你正在做的系统真正的做好。</p>
                <p>&nbsp;</p>
                <blockquote><p>我和大牛之间有多少距离？</p>
                </blockquote>
                <p>跟很多人一样，刚毕业时我觉得作为程序员，只要努力，加上少许天赋便可以获得一些成绩。</p>
                <p>工作一段时间后，对自己和其他人的认识也越来越清晰，逐渐的发现程序员之间的差距或许比人和猴子之间的差距还大，接受这个事实这让我郁闷了很久。</p>
                <p>再过一段时间，发现自己已经能够客观的评价自己的能力，也意识到了距离并不是那么重要，只要想办法跑的更快，就足够了。</p>
                <p>&nbsp;</p>
                <p>一个能担负起企业级应用的架构师，脑海里常出现的词会是这些：负载均衡、集群、分布式、高并发、高可用、易扩展、降级、回滚、紧急预案等。</p>
                <p>（1）数据层：重点在于集群方案的选择，比如MySQL集群，集群方案很多，需要选择符合业务的方案，比如多主，主备，读写分离等等，是否还需要做高可用，是用lvs，还是zookeeper，是否需要例如mycat类中间件来管理数据库或者做数据分片等等。</p>
                <p>（2）服务层：时髦一点，选择dubbo，微服务让团队开发耦合度没有那么高，各自关心各自的模块，都以服务方式发布出去。传统一点用springmvc+restful，在我看来，对于并发不高的系统，没有必要用dubbo。﻿缓存的选择，涉及到文件缓存、数据库缓存，可以用memcached、ehcache、redis。</p>
                <p>（3）应用层：框架太多，ssh,ssm,jfinal等等，选择适合项目团队的框架；UI界面，h5很美观，但对于浏览器的兼容就把开发人员搞哭了，可以选择成熟的ext或者easyui。</p>
                <p>（4）网络层：tcp/ip,机房架构，f5等。</p>
                <p>（5）部署：是否需要用docker来部署，开源docker容器让部署轻量化，很容易就可以扩展一个节点，对于高并发、伸缩性要求高的场景可以使用。docker的出现，完全可以实现一键部署。是否需要负载均衡，可以选择硬负载（就是前面说的f5），也可以用软负载（nginx）。软负载的方案简单一点可以是apache+tomcat，需要考虑session复制，复杂一点选择lvs+haproxy。﻿打包发布，熟练使用maven，能建立自己的maven私服，能指导项目成员使用maven打包发布。</p>
                <p>（6）安全：大多数安全在网络层就解决了，但应用的安全不容忽视，比如需要考虑SQL注入，授权认证，这些目前框架都能解决，重点的安全问题来自框架本身，大多数应用选择框架都是开源的，如果团队没有能力修复漏洞只能等更新。</p>
                <p>（7）其它方面：测试（自动化测试），版本管理，大数据，人工智能 等等。</p>
                <p>&nbsp;</p>
                <p>&quot;这个项目的架构是什么？&quot;</p>
                <p>对方爽快的回答：&quot;Spring+Struts+Hibernate。&quot;这位很可能就不是架构师了，因为这仅仅是技术Stack。</p>
               {/* <p><img src={require('../../img/1518965336960.jpg')} style={{height:"100%",width:"100%"}}/></p>*/}
                <p><img src="http://i4.bvimg.com/633340/37402fde3bbc208f.jpg" style={{height:"100%",width:"100%"}}/></p>

                <p>&nbsp;</p>
                <p>又如：</p>
                {/*<p><img src={require('../../img/WX20180218-225930@2x.png')}  style={{height:"80%",width:"80%"}}/></p>*/}
                <p><img src="http://i4.bvimg.com/633340/85f1f176e8125a36.png" style={{height:"100%",width:"100%"}}/></p>
                <p>&nbsp;</p>
            </div>
        );
    }
}

export default CTO3;